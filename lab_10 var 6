#include <iostream>
#include <string>
#include <sstream>
#include <stdexcept>
#include <type_traits>

using namespace std;

template <typename T, size_t MaxSize>
class LimitedStack {
private:
    T data[MaxSize];
    size_t topIndex;

public:
    LimitedStack();
    
    auto get() const -> decltype(auto);
    void push(const T& element);
    void pop();
    
    auto isEmpty() const -> decltype(topIndex == 0);
    auto isFull() const -> decltype(topIndex >= MaxSize);
    
    auto size() const;
    static auto maxSize() -> decltype(MaxSize);
    
    std::string toString() const;
    void clear();
    
    template <typename U, size_t S>
    friend auto operator<<(std::ostream& stream, const LimitedStack<U, S>& stack) 
        -> decltype(stream << stack.data[0], stream);
    
    template <typename U, size_t S>
    friend auto operator>>(std::istream& stream, LimitedStack<U, S>& stack)
        -> decltype(stream >> stack.data[0], stream);
};

template <typename T, size_t MaxSize>
LimitedStack<T, MaxSize>::LimitedStack() : topIndex(0) {
    static_assert(std::is_copy_constructible<T>::value, 
                  "Type T must be copy constructible for LimitedStack");
    
    static_assert(std::is_copy_assignable<T>::value, 
                  "Type T must be copy assignable for LimitedStack");
}

template <typename T, size_t MaxSize>
auto LimitedStack<T, MaxSize>::get() const -> decltype(auto) {
    if (isEmpty()) {
        throw std::out_of_range("Stack is empty");
    }
    return data[topIndex - 1];
}

template <typename T, size_t MaxSize>
void LimitedStack<T, MaxSize>::push(const T& element) {
    if (isFull()) {
        throw std::overflow_error("Stack overflow: maximum size reached");
    }
    data[topIndex] = element;
    topIndex++;
}

template <typename T, size_t MaxSize>
void LimitedStack<T, MaxSize>::pop() {
    if (isEmpty()) {
        throw std::out_of_range("Stack underflow: cannot pop from empty stack");
    }
    topIndex--;
}

template <typename T, size_t MaxSize>
auto LimitedStack<T, MaxSize>::isEmpty() const -> decltype(topIndex == 0) {
    return topIndex == 0;
}

template <typename T, size_t MaxSize>
auto LimitedStack<T, MaxSize>::isFull() const -> decltype(topIndex >= MaxSize) {
    return topIndex >= MaxSize;
}

template <typename T, size_t MaxSize>
auto LimitedStack<T, MaxSize>::size() const {
    return topIndex;
}

template <typename T, size_t MaxSize>
auto LimitedStack<T, MaxSize>::maxSize() -> decltype(MaxSize) {
    return MaxSize;
}

template <typename T, size_t MaxSize>
std::string LimitedStack<T, MaxSize>::toString() const {
    std::ostringstream oss;
    oss << "LimitedStack[";
    
    for (auto i = 0U; i < topIndex; i++) {
        oss << data[i];
        if (i < topIndex - 1) {
            oss << ", ";
        }
    }
    oss << "] (size=" << size() << ", max=" << MaxSize << ")";
    return oss.str();
}

template <typename T, size_t MaxSize>
void LimitedStack<T, MaxSize>::clear() {
    topIndex = 0;
}

template <typename T, size_t MaxSize>
auto operator<<(std::ostream& stream, const LimitedStack<T, MaxSize>& stack) 
    -> decltype(stream << stack.data[0], stream) {
    stream << "[";
    for (auto i = 0U; i < stack.topIndex; i++) {
        stream << stack.data[i];
        if (i < stack.topIndex - 1) {
            stream << " ";
        }
    }
    stream << "]";
    return stream;
}

template <typename T, size_t MaxSize>
auto operator>>(std::istream& stream, LimitedStack<T, MaxSize>& stack)
    -> decltype(stream >> stack.data[0], stream) {
    stack.clear();
    
    T element;
    auto count = 0U;
    
    while (count < MaxSize && stream >> element) {
        stack.push(element);
        count++;
    }
    
    return stream;
}

int main() {
    cout << "=== Тестирование LimitedStack ===" << endl;
    
    auto stack = LimitedStack<int, 5>();
    
    cout << "\n=== Добавление элементов ===" << endl;
    try {
        for (auto value : {10, 20, 30, 40, 50}) {
            stack.push(value);
            cout << "Добавлен " << value << ": " << stack.toString() << endl;
        }
        
        cout << "\nПопытка добавить сверх лимита: ";
        stack.push(60);
    } catch (const std::overflow_error& e) {
        cout << "Ошибка: " << e.what() << endl;
    }
    
    cout << "\n=== Получение элементов ===" << endl;
    try {
        cout << "Верхний элемент: " << stack.get() << endl;
    } catch (const std::out_of_range& e) {
        cout << "Ошибка: " << e.what() << endl;
    }
    
    cout << "\n=== Удаление элементов ===" << endl;
    try {
        for (auto i = 0; i < 3; i++) {
            cout << "Перед pop: " << stack.toString() << endl;
            stack.pop();
            cout << "После pop: " << stack.toString() << endl;
        }
    } catch (const std::out_of_range& e) {
        cout << "Ошибка: " << e.what() << endl;
    }
    
    cout << "\n=== Вывод через operator<< ===" << endl;
    cout << "Стек: " << stack << endl;
    
    auto copyStack = stack;
    cout << "Копия стека: " << copyStack.toString() << endl;
    
    cout << "\n=== Работа со строками ===" << endl;
    auto stringStack = LimitedStack<string, 4>();
    
    for (const auto& str : {"Hello", "World", "from", "Stack"}) {
        stringStack.push(str);
    }
    
    cout << "Стек строк: " << stringStack << endl;
    cout << "Верхняя строка: " << stringStack.get() << endl;
    
    cout << "\n=== Ввод через поток ===" << endl;
    auto inputStack = LimitedStack<double, 3>();
    
    cout << "Введите до 3 чисел (например: 1.1 2.2 3.3): ";
    cin.clear();
    cin.ignore(1000, '\n');
    
    cin >> inputStack;
    cout << "Результат: " << inputStack << endl;
    
    cout << "\n=== Тест с пользовательским типом ===" << endl;
    struct Point {
        int x, y;
        
        friend ostream& operator<<(ostream& os, const Point& p) {
            return os << "(" << p.x << "," << p.y << ")";
        }
        
        friend istream& operator>>(istream& is, Point& p) {
            return is >> p.x >> p.y;
        }
    };
    
    auto pointStack = LimitedStack<Point, 2>();
    pointStack.push({1, 2});
    pointStack.push({3, 4});
    
    cout << "Стек точек: " << pointStack << endl;
    
    return 0;
}
